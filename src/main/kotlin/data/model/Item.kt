package data.model

import character.Buff
import character.Proc
import character.Stats
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import data.Constants
import data.model.deserialize.ItemDeserializer

@JsonDeserialize(using = ItemDeserializer::class)
open class Item : ModelBase() {
    // Flag for ItemGen - all generated Items will have this set to true
    // If an item is manually edited, set this to false to prevent future ItemGen runs from overwriting
    open var isAutoGenerated: Boolean = false

    // Item attributes
    open var name: String = ""
    open var itemLevel: Int = 0

    // TODO: Validate itemSubclass is indeed a subclass of the itemClass
    // TODO: The defaults here might cause some unexpected results if deserialization isn't careful
    open var itemClass: Constants.ItemClass = Constants.ItemClass.WEAPON
    open var itemSubclass: Constants.ItemSubclass = Constants.ItemSubclass.FIST

    // TODO: This assumes physical damage types for items
    // TODO: Multiple damage types
    open var minDmg: Double = 0.0
    open var maxDmg: Double = 0.0
    open var speed: Double = 1000.0

    // Stats
    open var stats: Stats = Stats()

    // Sockets
    open var sockets: List<Socket> = listOf()
    open var socketBonus: List<Pair<Constants.StatType, Int>>? = null

    open val metaGemActive: Boolean
        get() {
            val byType = sockets.groupBy { it.color }
            return byType[Color.RED]?.size ?: 0 >= 2 &&
                    byType[Color.YELLOW]?.size ?: 0 >= 2 &&
                    byType[Color.BLUE]?.size ?: 0 >= 2
        }

    // Procs and effects
    open var enchant: Buff? = null
    open var temporaryEnhancement: Buff? = null
    open var procs: List<Proc> = listOf()

    // Helpers
    open val avgDmg: Double
        get() { return (minDmg + maxDmg) / 2}
    open val dps: Double
        get() { return avgDmg / speed }
}
